# üö® FrameSense Payment Integration - Problem Analysis & Solutions

## üìã **Aktuellt Problem**
**Symptom**: N√§r anv√§ndare loggar in p√• hemsidan (localhost:3000) registreras inte denna inloggning i desktop-appen.

## üîç **M√∂jliga Rotorsaker - Komplett Analys**

### **1. BACKEND WEBHOOK PROBLEM**
**Problem**: Stripe webhook n√•r aldrig backend eller processas inte korrekt.

**M√∂jliga orsaker**:
- Webhook URL √§r fel konfigurerad i Stripe Dashboard
- Webhook secret √§r fel eller saknas
- Backend lyssnar inte p√• r√§tt endpoint
- Webhook events n√•r backend men parsas fel

**Diagnostik**:
```bash
# Kolla Stripe webhook logs i dashboard
# Kolla backend logs f√∂r webhook events
# Testa manuellt med ngrok/webhook test
```

**L√∂sning A - Verifiera Webhook**:
```javascript
// L√§gg till debug logging i webhook
router.post('/webhooks/stripe', express.raw({ type: 'application/json' }), (req, res) => {
  console.log('üéØ RAW WEBHOOK RECEIVED:', req.body.toString());
  console.log('üéØ HEADERS:', req.headers);
  // ... forts√§tt med webhook processing
});
```

---

### **2. DATABASE UPDATE PROBLEM**  
**Problem**: Webhook n√•r backend men anv√§ndaren uppdateras inte i databasen.

**M√∂jliga orsaker**:
- User ID matching misslyckas (client_reference_id vs user.id)
- AuthService.updateUser() funktion √§r trasig
- Databas-fil har fel permissions
- Race condition mellan webhook och status check

**Diagnostik**:
```bash
# Inspektera users.json efter webhook
# Kolla console logs f√∂r user ID matching
# Verifiera att updateUser() anropas
```

**L√∂sning B - Debug Database Updates**:
```javascript
// I webhook handler
console.log('üîç Looking for user with ID:', userId);
console.log('üîç Available users:', Object.keys(userData.users));
console.log('üîç Found user email:', userEmail);

// Efter update
console.log('üîç User updated in database:', userData.users[userEmail]);
```

---

### **3. FRONTEND STATUS CHECK PROBLEM**
**Problem**: Desktop-appen k√∂r aldrig status check eller kollar fel endpoint.

**M√∂jliga orsaker**:
- Auth token √§r utg√•nget eller ogiltigt
- API endpoint URL √§r fel
- CORS problem mellan frontend och backend
- Fetch request misslyckas tyst

**Diagnostik**:
```bash
# Kolla network tab i dev tools
# Kolla console f√∂r fetch errors
# Verifiera auth token format
```

**L√∂sning C - Debug Status Check**:
```typescript
// I checkUserStatus()
console.log('üîç Making status check request with token:', this.currentUser.token.substring(0, 20) + '...');
console.log('üîç Request URL:', 'http://localhost:3001/api/check-status');

const response = await fetch('http://localhost:3001/api/check-status', {
  headers: {
    'Authorization': `Bearer ${this.currentUser.token}`,
  }
});

console.log('üîç Response status:', response.status);
console.log('üîç Response data:', await response.clone().json());
```

---

### **4. USER AUTHENTICATION STATE PROBLEM**
**Problem**: Desktop-appen har ingen anv√§ndare inloggad f√∂r att kolla status p√•.

**M√∂jliga orsaker**:
- Anv√§ndaren √§r inte inloggad i desktop-appen alls
- Session har f√∂rsvunnit eller rensats
- Auth token har g√•tt ut
- Login flow i appen √§r trasig

**Diagnostik**:
```bash
# Kolla currentUser state i debug mode
# Verifiera att login fungerar i appen
# Testa refresh status med inloggad user
```

**L√∂sning D - Fix Auth State**:
```typescript
// L√§gg till automatic login check vid app start
useEffect(() => {
  const checkAuthState = async () => {
    const user = await authService.getCurrentUser();
    if (!user) {
      console.log('‚ö†Ô∏è No user logged in - status check not possible');
      // Visa login prompt eller automatisk guest mode
    }
  };
  checkAuthState();
}, []);
```

---

### **5. TIMING/RACE CONDITION PROBLEM**
**Problem**: Desktop-appen kollar status innan webhook har uppdaterat databasen.

**M√∂jliga orsaker**:
- Webhook processar l√•ngsamt
- Status check h√§nder f√∂r snabbt efter betalning
- Stripe webhook leverans √§r f√∂rsenad
- Database write √§r async och inte v√§ntar

**L√∂sning E - Retry Mechanism**:
```typescript
// L√§gg till retry logic i status check
async checkUserStatusWithRetry(maxRetries = 3, delayMs = 2000): Promise<User | null> {
  for (let i = 0; i < maxRetries; i++) {
    const user = await this.checkUserStatus();
    
    if (user && user.tier !== 'free') {
      return user; // Success!
    }
    
    if (i < maxRetries - 1) {
      console.log(`üîÑ Status check attempt ${i + 1} failed, retrying in ${delayMs}ms...`);
      await new Promise(resolve => setTimeout(resolve, delayMs));
    }
  }
  
  return null;
}
```

---

## üõ†Ô∏è **ALTERNATIVA L√ñSNINGAR - Fr√•n Enklast till Komplexast**

### **ü•á L√ñSNING 1: MANUAL STATUS POLLING**
**Koncept**: Desktop-appen polllar backend med intervall f√∂r att kolla status.

**Implementation**:
```typescript
// I App.tsx - Auto polling efter payment
const startPaymentPolling = () => {
  const pollInterval = setInterval(async () => {
    const user = await authService.checkUserStatus();
    if (user && user.tier !== 'free') {
      clearInterval(pollInterval);
      alert(`üéâ Payment detected! You are now ${user.tier}!`);
    }
  }, 5000); // Kolla var 5:e sekund

  // Stop efter 2 minuter
  setTimeout(() => clearInterval(pollInterval), 120000);
};

// Anropa efter "Upgrade to Pro" klick
```

**F√∂r/Nackdelar**:
‚úÖ Enkel implementation
‚úÖ Fungerar oavsett webhook timing
‚ùå Polling √§r inte effektivt
‚ùå Anv√§ndaren m√•ste v√§nta

---

### **ü•à L√ñSNING 2: SHARED FILE SYSTEM**
**Koncept**: Backend skriver till fil n√§r webhook triggas, appen l√§ser filen.

**Implementation**:
```javascript
// I webhook handler (backend)
const fs = require('fs').promises;
const path = require('path');

// N√§r payment lyckas
const paymentStatusFile = path.join(os.homedir(), '.framesense', 'payment_status.json');
await fs.writeFile(paymentStatusFile, JSON.stringify({
  userId: userId,
  tier: newTier,
  timestamp: Date.now(),
  processed: true
}));
```

```typescript
// I desktop app
const checkPaymentFile = async () => {
  try {
    const statusFile = await invoke('read_payment_status_file');
    if (statusFile && statusFile.processed) {
      // Payment detected!
      await authService.checkUserStatus(); // Sync with server
      await invoke('clear_payment_status_file'); // Clean up
    }
  } catch (error) {
    // No file yet
  }
};
```

**F√∂r/Nackdelar**:
‚úÖ Real-time detection
‚úÖ Fungerar offline
‚ùå File system komplexitet
‚ùå Platform-specifik

---

### **ü•â L√ñSNING 3: WEBSOCKET REAL-TIME**
**Koncept**: Backend skickar real-time meddelande till desktop-app via WebSocket.

**Implementation**:
```javascript
// Backend WebSocket setup
const WebSocket = require('ws');
const wss = new WebSocket.Server({ port: 8080 });

// I webhook handler
wss.clients.forEach(client => {
  if (client.readyState === WebSocket.OPEN) {
    client.send(JSON.stringify({
      type: 'payment_success',
      userId: userId,
      tier: newTier
    }));
  }
});
```

```typescript
// Desktop app WebSocket client
useEffect(() => {
  const ws = new WebSocket('ws://localhost:8080');
  
  ws.onmessage = (event) => {
    const data = JSON.parse(event.data);
    if (data.type === 'payment_success' && data.userId === currentUser?.id) {
      authService.checkUserStatus(); // Refresh fr√•n server
      alert(`üéâ Payment Success! You are now ${data.tier}!`);
    }
  };
  
  return () => ws.close();
}, []);
```

**F√∂r/Nackdelar**:
‚úÖ Instant real-time updates
‚úÖ Skalbar f√∂r m√•nga users
‚ùå Komplex setup
‚ùå Kr√§ver WebSocket infrastructure

---

### **üèÜ L√ñSNING 4: BROWSER-APP BRIDGE**
**Koncept**: Hemsidan kommunicerar direkt med desktop-appen via custom protocol.

**Implementation**:
```html
<!-- I success.html p√• hemsidan -->
<script>
window.onload = () => {
  const urlParams = new URLSearchParams(window.location.search);
  const plan = urlParams.get('plan');
  
  // F√∂rs√∂k √∂ppna custom protocol
  window.location.href = `framesense://payment-success?plan=${plan}&timestamp=${Date.now()}`;
  
  // Fallback - visa meddelande
  setTimeout(() => {
    alert('Payment successful! Please refresh your FrameSense app.');
  }, 2000);
};
</script>
```

```rust
// I Tauri main.rs - Custom protocol handler
fn main() {
    tauri::Builder::default()
        .setup(|app| {
            app.listen_global("framesense://", |event| {
                if event.url().contains("payment-success") {
                  // Trigger app refresh
                  app.emit_all("payment_detected", {}).unwrap();
                }
            });
            Ok(())
        })
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
```

**F√∂r/Nackdelar**:
‚úÖ Direct browser-to-app communication
‚úÖ User-friendly (automatic)
‚ùå Platform-specific protocol setup
‚ùå Kan blockeras av browser security

---

## üéØ **REKOMMENDERAD L√ñSNING - HYBRID APPROACH**

**Kombinera L√ñSNING 1 + 2** f√∂r b√§sta resultat:

```typescript
// I App.tsx
const handleUpgradeClick = async () => {
  // 1. √ñppna Stripe checkout
  window.open('http://localhost:3000/payments', '_blank');
  
  // 2. Starta payment detection
  startPaymentDetection();
};

const startPaymentDetection = () => {
  console.log('üîç Starting payment detection...');
  
  let attempts = 0;
  const maxAttempts = 24; // 2 minuter (24 * 5s)
  
  const detectInterval = setInterval(async () => {
    attempts++;
    
    // Check file system first (fast)
    const fileStatus = await checkPaymentFile();
    if (fileStatus?.processed) {
      clearInterval(detectInterval);
      await authService.checkUserStatus();
      showPaymentSuccess(fileStatus.tier);
      return;
    }
    
    // Fallback: Direct server check
    const user = await authService.checkUserStatus();
    if (user && user.tier !== 'free') {
      clearInterval(detectInterval);
      showPaymentSuccess(user.tier);
      return;
    }
    
    // Timeout after max attempts
    if (attempts >= maxAttempts) {
      clearInterval(detectInterval);
      showPaymentTimeout();
    }
    
  }, 5000);
};

const showPaymentSuccess = (tier: string) => {
  alert(`üéâ Payment Successful!\n\nYou now have ${tier} access with all premium AI models!`);
};

const showPaymentTimeout = () => {
  alert('‚è±Ô∏è Payment detection timed out.\n\nIf you completed payment, click the üîÑ button to refresh manually.');
};
```

**Denna hybrid-l√∂sning**:
‚úÖ **Snabb** - File system check f√∂rst
‚úÖ **Robust** - Server fallback om fil saknas  
‚úÖ **User-friendly** - Automatisk detection + manual fallback
‚úÖ **Enkel** - Minimal komplexitet
‚úÖ **Reliable** - Fungerar √§ven om webhook √§r l√•ngsam

---

## üß™ **DEBUG PLAN - Steg f√∂r steg**

### **STEG 1: Verifiera Webhook**
```bash
# Kolla Stripe Dashboard ‚Üí Webhooks ‚Üí Logs
# Ser du 'checkout.session.completed' events?
# √Ñr webhook URL korrekt: http://localhost:3001/api/webhooks/stripe
```

### **STEG 2: Testa Webhook Manually**
```bash
# I backend console, l√§gg till:
console.log('üéØ WEBHOOK EVENT RECEIVED:', event.type);
console.log('üéØ USER ID FROM SESSION:', session.client_reference_id);
```

### **STEG 3: Verifiera Database Update**
```bash
# Efter webhook, kolla backend/data/users.json
# Har user tier uppdaterats fr√•n 'free' till 'premium'?
```

### **STEG 4: Testa Status Check**  
```bash
# I appen, klicka üîÑ button och kolla console
# Ser du API request till /api/check-status?
# Returnerar det uppdaterad tier?
```

### **STEG 5: Implementera Rekommenderad L√∂sning**
```bash
# Om alla ovan fungerar men timing √§r problemet
# Implementera hybrid payment detection
```

Detta kommer att l√∂sa problemet systematiskt! üöÄ 