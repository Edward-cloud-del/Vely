üîß PIECE 1: AUTHENTICATION BRIDGE
Problem:
Anv√§ndaren √§r inloggad p√• hemsidan men inte i Tauri-appen efter betalning.
L√∂sning:
Automatisk token-transfer fr√•n hemsida till app
Steg 1.1: F√∂rb√§ttra Success Page Token Handling
Fil: website/success.html

// F√∂rb√§ttra token-sparning f√∂r Tauri pickup
if (token && email) {
    const paymentCredentials = {
        token: token,
        email: email, 
        plan: plan,
        timestamp: Date.now(),
        session_id: sessionId,
        auto_login: true  // ‚Üê NY FLAG
    };
    
    // Spara via backend API (redan implementerat)
    await fetch('http://localhost:3001/api/save-payment-credentials', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(paymentCredentials)
    });
}

Steg 1.2: F√∂rb√§ttra Tauri Payment File Reader
// F√∂rb√§ttra check_payment_file() f√∂r auto-login
#[tauri::command]
async fn check_payment_file_and_login(
    auth_service: tauri::State<'_, SharedAuthService>
) -> Result<Option<User>, String> {
    // L√§s payment credentials
    if let Some(credentials) = check_payment_file().await? {
        if let (Some(token), Some(email)) = (
            credentials.get("token").and_then(|v| v.as_str()),
            credentials.get("email").and_then(|v| v.as_str())
        ) {
            // Automatisk login med token
            let service = {
                let guard = auth_service.lock().unwrap();
                guard.clone()
            };
            
            match service.verify_token(token.to_string()).await {
                Ok(user) => {
                    // Spara session lokalt
                    service.save_user_session(&user).await?;
                    println!("üéâ Auto-login successful: {} ({})", user.email, user.tier);
                    return Ok(Some(user));
                },
                Err(e) => println!("‚ö†Ô∏è Auto-login failed: {}", e)
            }
        }
    }
    Ok(None)
}
Steg 1.3: Uppdatera Frontend Auth Service
// L√§gg till auto-login check vid app start
async initialize() {
    // F√∂rst kolla befintlig session
    await this.loadCurrentUser();
    
    // Om ingen session, kolla payment file f√∂r auto-login
    if (!this.currentUser) {
        await this.checkPaymentFileAutoLogin();
    }
    
    // Sedan initiera deep link listener
    if (!this.deepLinkInitialized) {
        await this.initializeDeepLinkListener();
        this.deepLinkInitialized = true;
    }
}

private async checkPaymentFileAutoLogin(): Promise<void> {
    try {
        const user = await invoke<User | null>('check_payment_file_and_login');
        if (user) {
            this.currentUser = user;
            this.notifyAuthListeners(user);
            console.log('üéâ Auto-login from payment file successful');
        }
    } catch (error) {
        console.log('‚ÑπÔ∏è No payment file auto-login available');
    }
}
üîÑ PIECE 2: SMART POLLING TRIGGER
Intelligent polling som triggas av payment detection
Steg 2.1: Payment Detection Watcher
// L√§gg till payment detection watcher
private paymentPollingInterval: NodeJS.Timeout | null = null;

async startPaymentPolling(): Promise<void> {
    if (this.paymentPollingInterval) {
        clearInterval(this.paymentPollingInterval);
    }
    
    console.log('üîÑ Starting payment status polling...');
    let attempts = 0;
    const maxAttempts = 40; // 2 minuter (40 * 3s)
    
    this.paymentPollingInterval = setInterval(async () => {
        attempts++;
        
        try {
            // Kolla payment file f√∂rst (snabbt)
            const paymentUser = await invoke<User | null>('check_payment_file_and_login');
            if (paymentUser && paymentUser.tier !== 'free') {
                this.handlePaymentSuccess(paymentUser);
                return;
            }
            
            // Kolla server status (backup)
            const serverUser = await this.checkUserStatus();
            if (serverUser && serverUser.tier !== 'free') {
                this.handlePaymentSuccess(serverUser);
                return;
            }
            
            // Timeout check
            if (attempts >= maxAttempts) {
                this.stopPaymentPolling();
                console.log('‚è±Ô∏è Payment polling timeout - manual check required');
                this.showPaymentTimeoutMessage();
            }
            
        } catch (error) {
            console.error('‚ùå Payment polling error:', error);
        }
    }, 3000); // Polla var 3:e sekund
}

private handlePaymentSuccess(user: User): void {
    this.stopPaymentPolling();
    this.currentUser = user;
    this.notifyAuthListeners(user);
    
    // Visa success meddelande
    this.showPaymentSuccessNotification(user.tier);
    
    // Emit event f√∂r UI uppdatering
    window.dispatchEvent(new CustomEvent('payment_verified', { 
        detail: { user } 
    }));
}

private stopPaymentPolling(): void {
    if (this.paymentPollingInterval) {
        clearInterval(this.paymentPollingInterval);
        this.paymentPollingInterval = null;
        console.log('‚èπÔ∏è Payment polling stopped');
    }
}
Steg 2.2: Trigger Polling fr√•n UI
// L√§gg till payment polling trigger
const handleUpgradeClick = async () => {
    // √ñppna payment sida
    window.open('http://localhost:3000/payments', '_blank');
    
    // Starta payment detection
    await authService.startPaymentPolling();
    
    // Visa polling UI
    setIsWaitingForPayment(true);
};

// Lyssna p√• payment verification
useEffect(() => {
    const handlePaymentVerified = (event: CustomEvent) => {
        setIsWaitingForPayment(false);
        const { user } = event.detail;
        alert(`üéâ Payment Verified!\n\nYou now have ${user.tier} access!`);
    };
    
    window.addEventListener('payment_verified', handlePaymentVerified);
    return () => window.removeEventListener('payment_verified', handlePaymentVerified);
}, []);
üí¨ PIECE 3: USER FEEDBACK
Tydlig progress feedback under payment verification
// Ny komponent f√∂r payment waiting
interface PaymentWaitingProps {
    isVisible: boolean;
    onManualCheck: () => void;
    onCancel: () => void;
}

export const PaymentWaiting: React.FC<PaymentWaitingProps> = ({
    isVisible,
    onManualCheck,
    onCancel
}) => {
    const [dots, setDots] = useState('');
    
    useEffect(() => {
        if (!isVisible) return;
        
        const interval = setInterval(() => {
            setDots(prev => prev.length >= 3 ? '' : prev + '.');
        }, 500);
        
        return () => clearInterval(interval);
    }, [isVisible]);
    
    if (!isVisible) return null;
    
    return (
        <div className="payment-waiting-overlay">
            <div className="payment-waiting-content">
                <div className="spinner" />
                <h3>Verifying Payment{dots}</h3>
                <p>Please wait while we confirm your subscription...</p>
                
                <div className="payment-waiting-actions">
                    <button onClick={onManualCheck}>
                        Check Manually
                    </button>
                    <button onClick={onCancel}>
                        Cancel
                    </button>
                </div>
                
                <div className="payment-waiting-help">
                    <p>Taking too long?</p>
                    <ul>
                        <li>‚úÖ Complete payment in browser</li>
                        <li>üîÑ Click "Check Manually"</li>
                        <li>üìß Check email for confirmation</li>
                    </ul>
                </div>
            </div>
        </div>
    );
};

Steg 3.2: Integrera i Main App
// L√§gg till payment waiting state
const [isWaitingForPayment, setIsWaitingForPayment] = useState(false);

// Hantera manual check
const handleManualPaymentCheck = async () => {
    try {
        const user = await authService.checkUserStatus();
        if (user && user.tier !== 'free') {
            setIsWaitingForPayment(false);
            alert(`üéâ Payment Found!\n\nYou now have ${user.tier} access!`);
        } else {
            alert('‚è≥ Payment not found yet. Please wait or try again.');
        }
    } catch (error) {
        alert('‚ùå Error checking payment status. Please try again.');
    }
};

// Render payment waiting overlay
return (
    <div className="app">
        {/* Existing app content */}
        
        <PaymentWaiting
            isVisible={isWaitingForPayment}
            onManualCheck={handleManualPaymentCheck}
            onCancel={() => {
                authService.stopPaymentPolling();
                setIsWaitingForPayment(false);
            }}
        />
    </div>
);